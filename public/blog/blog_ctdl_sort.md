## C√°c thu·∫≠t to√°n s·∫Øp x·∫øp

H√¥m nay ch√∫ng ta s·∫Ω c√πng t√¨m hi·ªÉu v·ªÅ c√°c thu·∫≠t to√°n s·∫Øp x·∫øp v√† ph√¢n t√≠ch ƒëi·ªÉm m·∫°nh, y·∫øu v√† tr∆∞·ªùng h·ª£p √°p d·ª•ng c·ªßa n√≥.

## 1. Nh√≥m s·∫Øp x·∫øp c∆° b·∫£n (Elementary Sort)
### 1.1 Bubble Sort, s·∫Øp s·∫øp n·ªïi b·ªçt - O(n¬≤)  
S·∫Øp x·∫øp n·ªïi b·ªçt xu·∫•t ph√°t t·ª´ vi·ªác ph·∫ßn t·ª≠ l·ªõn nh·∫•t "n·ªïi d·∫ßn" l√™n cu·ªëi m·∫£ng sau m·ªói l∆∞·ª£t duy·ªát, gi·ªëng nh∆∞ bong b√≥ng kh√≠ n·ªïi l√™n m·∫∑t n∆∞·ªõc.  
**C√°ch ho·∫°t ƒë·ªông:**
1. Duy·ªát qua m·∫£ng nhi·ªÅu l·∫ßn
2. ·ªû m·ªói l∆∞·ª£t, so s√°nh c·∫∑p ph·∫ßn t·ª≠ li·ªÅn k·ªÅ (arr[j], arr[j+1])
3. N·∫øu arr[j] > arr[j+1], ho√°n ƒë·ªïi ch√∫ng.
4. Sau l∆∞·ª£t th·ª© nh·∫•t, ph·∫ßn t·ª≠ l·ªõn nh·∫•t n·∫±m ·ªü cu·ªëi m·∫£ng -> kh√¥ng c·∫ßn x√©t l·∫°i ph·∫ßn t·ª≠ ƒë√≥ ·ªü l∆∞·ª£t sau.
5. L·∫∑p l·∫°i cho ƒë·∫øn khi kh√¥ng c√≤n ho√°n ƒë·ªïi n√†o.

Code python:
```Python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        # t·ªëi ∆∞u: n·∫øu kh√¥ng swap => d·ª´ng
        swapped = False
        for j in range(n - 1 - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                swapped = True
        if not swapped:
            break
    return arr

print(bubble_sort([5, 3, 8, 4, 2]))
# Output: [2, 3, 4, 5, 8]
```
### 1.2 Selection Sort, S·∫Øp x·∫øp ch·ªçn l·ª±a - O(n¬≤)
Thu·∫≠t to√°n n√†y d·ª±a tr√™n nguy√™n t·∫Øc : "M·ªói v√≤ng l·∫∑p, t√¨m ph·∫ßn t·ª≠ nh·ªè nh·∫•t trong ph·∫ßn ch∆∞a ƒë∆∞·ª£c s·∫Øp x·∫øp v√† ƒë∆∞a n√≥ l√™n ƒë·∫ßu."  
**C√°ch ho·∫°t ƒë·ªông:**
1. T√¨m ph·∫ßn t·ª≠ nh·ªè nh·∫•t t·ª´ to√†n b·ªô m·∫£ng
2. ƒê·ªïi v·ªã tr√≠ c·ªßa ph·∫ßn t·ª≠ nh·ªè nh·∫•t t√¨m ƒë∆∞·ª£c v√† ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n
3. L·∫∑p l·∫°i quy tr√¨nh ƒë√≥, v·ªõi v·ªã tr√≠ xu·∫•t ph√°t l√† i+1 so v·ªõi v·ªã tr√≠ duy·ªát tr∆∞·ªõc ƒë√≥

Code python:
```python
def selection_sort(arr):
    n = len(arr)
    for i in range(n - 1):
        min_index = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
    return arr

print(selection_sort([5, 3, 8, 4, 2]))
# Output: [2, 3, 4, 5, 8]
```

### 1.3 Insertion Sort, S·∫Øp x·∫øp ch√®n - O(n¬≤), t·ªët nh·∫•t O(n)
Thu·∫≠t to√°n n√†y m√¥ ph·ªèng c√°ch b·∫°n x·∫øp b√†i tr√™n tay: "L·∫•y t·ª´ng l√° b√†i (ph·∫ßn t·ª≠) v√† ch√®n n√≥ v√†o ƒë√∫ng v·ªã tr√≠ trong ph·∫ßn c√°c l√° ƒë√£ ƒë∆∞·ª£c s·∫Øp."  
**C√°ch ho·∫°t ƒë·ªông:**
1. B·ªè qua ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n coi nh∆∞ ƒë√£ s·∫Øp x·∫øp
2. L·∫•y ph·∫ßn t·ª≠ th·ª© 2 so s√°nh v·ªõi ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n, n·∫øu nh·ªè h∆°n ch√®n l√™n tr∆∞·ªõc ph·∫ßn t·ª≠ ƒë·∫ßu ti√™n.
3. L·∫∑p l·∫°i quy tr√¨nh n√†y, l·∫•y ph·∫ßn t·ª≠ t·∫°i i, so s√°nh v·ªõi c√°c ph·∫ßn t·ª≠ j t·ª´ i-1 -> 0, t·∫°i v·ªã tr√≠ j n·∫øu a[j] > a[i], ta g√°n a[j+1] = a[j]. N·∫øu g·∫∑p a[j] <= a[i] ta d·ª´ng l·∫∑p v√† g√°n a[j+1] = a[i] ban ƒë·∫ßu.

V√≠ d·ª•: [2, 3, 8, 4, 5, 8]  
1. i = 3, a[i] = 4.
2. ta l·∫∑p j = i-1 -> 0.   
v·ªõi j = 2 a[1] = 8 > 4 -> ta g√°n a[2] = 8.  
v·ªõi j = 1 a[0] = 3 < 4 -> ta d·ª´ng v√† g√°n a[1] = 4.
3. ta thu ƒë∆∞·ª£c, [2, 3, 4, 8, 5, 8]  

Code python:
```Python
def insertion_sort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i - 1
        # d·ªãch chuy·ªÉn ph·∫ßn t·ª≠ l·ªõn h∆°n key sang ph·∫£i
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
    return arr

print(insertion_sort([5, 3, 8, 4, 2]))
# Output: [2, 3, 4, 5, 8]
```

### 1.4 Shell Sort - O(n log¬≤ n)
Shell Sort l√† m·ªôt phi√™n b·∫£n n√¢p c·∫•p h∆°n c·ªßa **Insertion Sort**
√ù t∆∞·ªüng ch√≠nh c·ªßa thu·∫≠t to√°n: Thay v√¨ ch√®n t·ª´ng ph·∫ßn t·ª≠ v√†o ƒë√∫ng v·ªã tr√≠ ngay t·ª´ ƒë·∫ßu nh∆∞ Insertion Sort, ta so s√°nh v√† ch√®n c√°c ph·∫ßn t·ª≠ c√°ch nhau 1 kho·∫£ng (gap), r·ªìi gi·∫£m d·∫ßn kho·∫£ng c√°ch cho ƒë·∫øn khi gap = 1   
Ng·∫Øn g·ªçn:
1. Insertion Sort ch√®n ph·∫ßn t·ª≠ li·ªÅn k·ªÅ -> ch·∫≠m n·∫øt ph·∫ßn t·ª≠ c√°ch xa.
2. Shell Sort cho ph√©p c√°c ph·∫ßn t·ª≠ "nh·∫£y xa h∆°n" ƒë·ªÉ ƒë·∫øn g·∫ßn v·ªã tr√≠ ƒë√∫ng nhanh h∆°n.

**C√°ch ho·∫°t ƒë·ªông:**
1. Gi·∫£ s·ª≠: [5, 3, 8, 4, 2, 1]
2. Ch·ªçn gap = n/2 = 3. So s√°nh c√°c ph·∫ßn t·ª≠ c√°ch nhau 3 v·ªã tr√≠ -> [4, 2, 1, 5, 3, 8]
3. Ch·ªçn gap = n/2 = 1.5 = 1. Th·ª±c hi·ªán Insertion Soft tr√™n to√†n m·∫£ng.

Code python:
```Python
def shell_sort(arr):
    n = len(arr)
    gap = n // 2

    while gap > 0:
        for i in range(gap, n):
            temp = arr[i]
            j = i
            # D·ªãch chuy·ªÉn ph·∫ßn t·ª≠ theo kho·∫£ng c√°ch gap
            while j >= gap and arr[j - gap] > temp:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = temp
        gap //= 2  # Gi·∫£m kho·∫£ng c√°ch
    return arr

print(shell_sort([5, 3, 8, 4, 2, 1]))
# Output: [1, 2, 3, 4, 5, 8]
```

## 2. Nh√≥m s·∫Øp x·∫øp chia ƒë·ªÉ tr·ªã (Divide & Conquer)
### 2.1 Merge Sort O(n log n)
Thu·∫≠t to√°n merge sort d·ª±a tr√™n t∆∞ t∆∞·ªüng chia ƒë·ªÉ tr·ªã, c·ª• th·ªÉ n√≥ s·∫Ω chia nh·ªè d·ªØ li·ªáu ban ƒë·∫ßu th√†nh c√°c ph·∫ßn nh·ªè h∆°n, sau ƒë√≥ s·∫Øp x·∫øp v√† tr·ªôn n√≥ l·∫°i.  
- Merge Sort = Chia nh·ªè + S·∫Øp t·ª´ng ph·∫ßn + Tr·ªôn l·∫°i.  

V√≠ d·ª•: [5, 3, 8, 4, 2, 7, 1, 6]  
1. B∆∞·ªõc 1: Chia  
Chia ƒë√¥i li√™n t·ª•c cho ƒë·∫øn khi ch·ªâ c√≤n 1 ph·∫ßn t·ª≠:
```text
[5, 3, 8, 4]    [2, 7, 1, 6]
[5, 3] [8, 4]   [2, 7] [1, 6]
[5] [3] [8] [4] [2] [7] [1] [6]
```
2. B∆∞·ªõc 2: Tr·ªã (s·∫Øp x·∫øp t·ª´ng m·∫£ng con 1 ph·∫ßn t·ª≠ ‚Üí 2 ph·∫ßn t·ª≠)  
```text
[3,5] [4,8] [2,7] [1,6]
```
3. B∆∞·ªõc 3: Tr·ªôn d·∫ßn l·∫°i
```text
[3,4,5,8] [1,2,6,7]
‚Üí [1,2,3,4,5,6,7,8] ‚úÖ
```
Code Python: 
```text
def merge_sort(arr):
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])

    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0

    # tr·ªôn hai m·∫£ng con
    while i < len(left) and j < len(right):
        if left[i] < right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1

    # n·ªëi ph·∫ßn c√≤n l·∫°i (n·∫øu c√≥)
    result.extend(left[i:])
    result.extend(right[j:])
    return result

print(merge_sort([5, 3, 8, 4, 2, 7, 1, 6]))
# üëâ Output: [1, 2, 3, 4, 5, 6, 7, 8]
```

#### Ch·ª©ng minh ƒë·ªô ph·ª©c t·∫°p thu·∫≠t to√°n:  
**C√°ch 1:**  
Merge Sort chia ƒë√¥i li√™n t·ª•c, ta nh·∫≠n ƒë∆∞·ª£c 1 c√¢y nh·ªã ph√¢n, c√≥ log(n) t·∫ßng. (n/2^k = 1 -> k=log(n))  
·ªû m·ªói t·∫ßng, kh·ªëi l∆∞·ª£ng c√¥ng vi·ªác th·ª±c hi·ªán l√† n. Trong merge sort, c√¥ng vi·ªác ch·ªß y·∫øu ƒë·∫øn t·ª´ b∆∞·ªõc merge.
- Khi g·ªôp hai m·∫£ng con k√≠ch th∆∞·ªõc m, chi ph√≠ l√† O(m) (ph·∫£i duy·ªát qua m·ªçi ph·∫ßn t·ª≠ 1 l·∫ßn).
- ·ªû t·∫ßng n√†o th√¨ t·ªïng k√≠ch th∆∞·ªõc c√°c m·∫£ng c·∫ßn merge = n ‚áí t·ªïng chi ph√≠ t·∫ßng ƒë√≥ = O(n).

Kh√¥ng quan tr·ªçng b·∫°n c√≥ 2 m·∫£ng to hay 8 m·∫£ng nh·ªè ‚Äî t·ªïng s·ªë ph·∫ßn t·ª≠ ƒë∆∞·ª£c ‚Äúduy·ªát qua‚Äù ƒë·ªÉ merge m·ªói t·∫ßng lu√¥n l√† n.

**C√°ch 2:**  
Ta c√≥ ·ªü m·ªói l·∫ßn mergeSort = mergeSort(n/2) + mergeSort(n/2) + merge(a,b)   
V√¨ m·ªói l·∫ßn merge t·ªën n c√¥ng vi·ªác (duy·ªát qua to√†n b·ªô ph·∫ßn t·ª≠)  
-> T(n) = 2T(n/2) + n (1)  
Ta c√≥: T(n/2) = 4T(n/4) + n (2)

T·ª´ (1) v√† (2) ta c√≥ c√¥ng th·ª©c t·ªïng qu√°t => T(n) = 2^k . T(n/2^k) + kn  
C√¥ng th·ª©c lu√¥n ƒë√∫ng v·ªõi m·ªçi k, ta thay k = log2(n) (ƒë√¢y l√† s·ªë t·∫ßng)  
-> T(n) = n.T(1) + log2(n).n, √Åp d·ª•ng quy t·∫Øc c·ªông -> **T(n) = log2(n)n**
### 2.2 Quick Sort O(n log n), x·∫•u nh·∫•t O(n¬≤)
Quick Sort, ng∆∞·ªùi anh em c·ªßa Merge Sort nh∆∞ng th·ª±c t·∫ø th∆∞·ªùng nhanh h∆°n v√† ƒë∆∞·ª£c d√πng nhi·ªÅu h∆°n trong th∆∞ vi·ªán chu·∫©n (C, C++, Java, Python, v.v.).  
V·ªÅ t∆∞ t∆∞·ªüng, QuickSort c≈©ng d·ª±a tr√™n chia ƒë·ªÉ tr·ªã, nh∆∞ng kh√°c MergeSort v·ªÅ c√°ch chia.   
**C√°ch ho·∫°t ƒë·ªông:**
1. Ch·ªçn ph·∫ßn t·ª≠ l√†m ch·ªët (pivot)
2. Ph√¢n chia m·∫£ng:
- c√°c ph·∫ßn t·ª≠ nh·ªè h∆°n pivot ƒë∆∞a sang tr√°i
- c√°c ph·∫ßn t·ª≠ l·ªõn h∆°n pivot ƒë∆∞a sang ph·∫£i
3. G·ªçi ƒë·ªá quy s·∫Øp x·∫øp hai n·ª≠a (tr√°i, ph·∫£i)
4. Gh√©p l·∫°i (pivot ƒë·ª©ng gi·ªØa ‚Üí kh√¥ng c·∫ßn merge nh∆∞ Merge Sort)
   
**V√≠ d·ª•:**
1. Ta c√≥ m·∫£ng ``` [8, 3, 1, 7, 0, 10, 2] ```
2. Ch·ªçn pivot. Gi·∫£ s·ª≠ pivot = 7.  
Ph√¢n ho·∫°ch: ``` [3, 1, 0, 2] | 7 | [8, 10] ```
3. ƒê·ªá quy s·∫Øp x·∫øp t·ª´ng n·ª≠a
- Tr√°i ``` [3, 1, 0, 2] ‚Üí [0, 1, 2, 3] ```
- Ph·∫£i ``` [8, 10] ‚Üí [8, 10] ```
4. Gh√©p l·∫°i : ``` [0, 1, 2, 3] + [7] + [8, 10] = [0, 1, 2, 3, 7, 8, 10] ```

**Code python:**
```Python
def quick_sort(arr):
    if len(arr) <= 1:
        return arr
    pivot = arr[len(arr)//2]     # ch·ªçn pivot ·ªü gi·ªØa
    left  = [x for x in arr if x < pivot]
    mid   = [x for x in arr if x == pivot]
    right = [x for x in arr if x > pivot]
    return quick_sort(left) + mid + quick_sort(right)

print(quick_sort([8, 3, 1, 7, 0, 10, 2]))
# Output: [0, 1, 2, 3, 7, 8, 10]
```
**Quy t·∫Øc ch·ªçn pivot:**
- Ch·ªçn pivot t·ªët ‚Üí c√¢y ƒë·ªá quy c√¢n b·∫±ng ‚Üí log n t·∫ßng ‚Üí n log n.
- Ch·ªçn pivot t·ªá ‚Üí c√¢y l·ªách ‚Üí n t·∫ßng ‚Üí n¬≤.
### 2.3 Heap Sort - O(n log n)
Heap sort l√† m·ªôt thu·∫≠t to√°n s·∫Øp x·∫øp c·ªï ƒëi·ªÉn nh∆∞ng c·ª±c k√¨ m·∫°nh, n√≥ lu√¥n ch·∫°y O(nlog(n)) trong m·ªçi tr∆∞·ªùng h·ª£p, kh√¥ng c·∫ßn b·ªô nh·ªõ ph·ª• nh∆∞ Merge sort.  
**√ù t∆∞·ªüng:**
Heap Sort = D·ª±ng c√¢y Heap + Tr√≠ch ph·∫ßn t·ª≠ l·ªõn nh·∫•t li√™n t·ª•c
1. X√¢y d·ª±ng Max-Heap t·ª´ m·∫£ng (m·ªói n√∫t l·ªõn h∆°n hai con).
2. ƒê∆∞a ph·∫ßn t·ª≠ l·ªõn nh·∫•t (root) v·ªÅ cu·ªëi m·∫£ng.
4. Gi·∫£m k√≠ch th∆∞·ªõc heap, v√† heapify l·∫°i ƒë·ªÉ ph·∫ßn t·ª≠ l·ªõn nh·∫•t k·∫ø ti·∫øp n·ªïi l√™n.
5. L·∫∑p l·∫°i cho ƒë·∫øn khi m·∫£ng ƒë∆∞·ª£c s·∫Øp x·∫øp.

**V√≠ d·ª•:**
1. M·∫£ng ban ƒë·∫ßu: ```[4, 10, 3, 5, 1]```
2. X√¢y c√¢y Heap: Bi·∫øn c√¢y tho·∫£ m√£n: cha ‚â• con
```
       10
      /  \
     5    3
    / \
   4   1
```
-> M·∫£ng Heap t∆∞∆°ng ·ª©ng : ```M·∫£ng heap t∆∞∆°ng ·ª©ng: [10, 5, 3, 4, 1]```
3. ƒê∆∞a max (10) v·ªÅ cu·ªëi ```Swap 10 - 1```  
   ‚Üí Gi·∫£m k√≠ch th∆∞·ªõc heap c√≤n 4, heapify l·∫°i ph·∫ßn c√≤n ```[1, 5, 3, 4]```  
   ‚Üí ```[5, 4, 3, 1, 10]```
4. L·∫∑p l·∫°i  
   Swap 5 ‚Üî 1 ‚Üí ```[1, 4, 3, 5, 10]``` ‚Üí heapify ```[1, 4, 3] ‚Üí [4, 1, 3, 5, 10]```  
   Swap 4 ‚Üî 3 ‚Üí ```[3, 1, 4, 5, 10]``` ‚Üí heapify ```[3,1] ‚Üí [3,1,4,5,10]```  
   Swap 3 ‚Üî 1 ‚Üí ```[1,3,4,5,10]```  
   ‚úÖ K·∫øt qu·∫£ cu·ªëi c√πng: ```[1, 3, 4, 5, 10]```

**Code python:**
```Python
def heapify(arr, n, i):
    largest = i
    left = 2*i + 1
    right = 2*i + 2

    if left < n and arr[left] > arr[largest]:
        largest = left
    if right < n and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    # 1. X√¢y d·ª±ng max heap
    for i in range(n//2 - 1, -1, -1):
        heapify(arr, n, i)

    # 2. Tr√≠ch ph·∫ßn t·ª≠ l·ªõn nh·∫•t
    for i in range(n-1, 0, -1):
        arr[0], arr[i] = arr[i], arr[0]
        heapify(arr, i, 0)

arr = [4, 10, 3, 5, 1]
heap_sort(arr)
print(arr)
# Output: [1, 3, 4, 5, 10]
```

## 3. Nh√≥m s·∫Øp x·∫øp theo ƒë·∫øm & ph√¢n ph·ªëi (Non-Comparison)
3.1 Counting Sort O(n + k)

3.2 Bucket Sort O(n + k)

3.3 Radix Sort O(n * k)

## 4. T·ªîNG K·∫æT C√ÅC THU·∫¨T TO√ÅN S·∫ÆP X·∫æP

### T·ªïng quan
Ph·∫ßn n√†y gi√∫p b·∫°n h·ªá th·ªëng l·∫°i to√†n b·ªô c√°c thu·∫≠t to√°n s·∫Øp x·∫øp ƒë√£ h·ªçc, so s√°nh ∆∞u ‚Äì nh∆∞·ª£c ƒëi·ªÉm, v√† n√™u r√µ tr∆∞·ªùng h·ª£p √°p d·ª•ng ph√π h·ª£p nh·∫•t trong th·ª±c t·∫ø.

### B·∫£ng t·ªïng h·ª£p

| Nh√≥m | Thu·∫≠t to√°n | ƒê·ªô ph·ª©c t·∫°p (T·ªët / TB / X·∫•u) | ·ªîn ƒë·ªãnh | B·ªô nh·ªõ ph·ª• | ƒê·∫∑c ƒëi·ªÉm ch√≠nh | Tr∆∞·ªùng h·ª£p √°p d·ª•ng |
|-------|-------------|-------------------------------|----------|--------------|----------------|--------------------|
| **C∆° b·∫£n (Elementary Sort)** | **Bubble Sort** | O(n) / O(n¬≤) / O(n¬≤) | ‚úÖ | O(1) | D·ªÖ hi·ªÉu, m√¥ ph·ªèng so s√°nh li·ªÅn k·ªÅ | Minh h·ªça h·ªçc thu·∫≠t, d·ªØ li·ªáu nh·ªè |
|  | **Selection Sort** | O(n¬≤) / O(n¬≤) / O(n¬≤) | ‚ùå | O(1) | M·ªói v√≤ng ch·ªçn min, √≠t swap | Khi c·∫ßn s·∫Øp x·∫øp t·∫°i ch·ªó, kh√¥ng y√™u c·∫ßu ·ªïn ƒë·ªãnh |
|  | **Insertion Sort** | O(n) / O(n¬≤) / O(n¬≤) | ‚úÖ | O(1) | M√¥ ph·ªèng x·∫øp b√†i, t·ªët khi g·∫ßn s·∫Øp | D·ªØ li·ªáu nh·ªè ho·∫∑c g·∫ßn c√≥ th·ª© t·ª± |
|  | **Shell Sort** | O(n log¬≤ n) / O(n^1.25‚Äìn^1.5) / O(n¬≤) | ‚ùå | O(1) | C·∫£i ti·∫øn Insertion Sort v·ªõi gap | Khi c·∫ßn s·∫Øp nhanh h∆°n insertion, √≠t RAM |
| **Chia ƒë·ªÉ tr·ªã (Divide & Conquer)** | **Merge Sort** | O(n log n) / O(n log n) / O(n log n) | ‚úÖ | O(n) | Chia nh·ªè, tr·ªôn l·∫°i, ·ªïn ƒë·ªãnh | D·ªØ li·ªáu l·ªõn, c·∫ßn ·ªïn ƒë·ªãnh |
|  | **Quick Sort** | O(n log n) / O(n log n) / O(n¬≤) | ‚ùå | O(log n) | Pivot chia ƒë√¥i, ƒë·ªá quy, nhanh nh·∫•t th·ª±c t·∫ø | D·ªØ li·ªáu ng·∫´u nhi√™n, hi·ªáu nƒÉng cao |
|  | **Heap Sort** | O(n log n) / O(n log n) / O(n log n) | ‚ùå | O(1) | D·ª±a tr√™n c√¢y Heap, ·ªïn ƒë·ªãnh v·ªÅ th·ªùi gian | Khi c·∫ßn t·ªëc ƒë·ªô ·ªïn ƒë·ªãnh, √≠t b·ªô nh·ªõ |
| **Theo ƒë·∫øm & ph√¢n ph·ªëi (Non-Comparison)** | **Counting Sort** | O(n + k) | ‚úÖ | O(k) | ƒê·∫øm t·∫ßn su·∫•t gi√° tr·ªã | D·ªØ li·ªáu nguy√™n, ph·∫°m vi nh·ªè |
|  | **Bucket Sort** | O(n + k) | ‚úÖ | O(n + k) | Chia d·ªØ li·ªáu th√†nh nh√≥m (bucket) | Khi d·ªØ li·ªáu ph√¢n b·ªë ƒë·ªÅu |
|  | **Radix Sort** | O(n √ó k) | ‚úÖ | O(n + k) | S·∫Øp theo t·ª´ng ch·ªØ s·ªë (Counting con) | D·ªØ li·ªáu c√≥ ƒë·ªô d√†i c·ªë ƒë·ªãnh (m√£, s·ªë ƒëi·ªán tho·∫°i...) |

## üîπ So s√°nh nhanh theo ti√™u ch√≠

| Ti√™u ch√≠ | Thu·∫≠t to√°n n·ªïi b·∫≠t |
|-----------|--------------------|
| **Nhanh nh·∫•t th·ª±c t·∫ø** | Quick Sort (pivot ng·∫´u nhi√™n / median-of-three) |
| **·ªîn ƒë·ªãnh nh·∫•t** | Merge Sort, Insertion Sort, Counting / Radix Sort |
| **√çt b·ªô nh·ªõ nh·∫•t** | Heap Sort, Quick Sort |
| **Ph√π h·ª£p d·ªØ li·ªáu nh·ªè** | Insertion Sort, Shell Sort |
| **Ph√π h·ª£p d·ªØ li·ªáu l·ªõn** | Merge Sort, Heap Sort, Quick Sort |
| **Ph√π h·ª£p d·ªØ li·ªáu s·ªë nguy√™n, ph·∫°m vi h·∫πp** | Counting Sort, Radix Sort |
| **Ph√π h·ª£p d·ªØ li·ªáu ph√¢n b·ªë ƒë·ªÅu** | Bucket Sort |

### ·ª®ng d·ª•ng th·ª±c t·∫ø (Case Study)

| Lƒ©nh v·ª±c | T√¨nh hu·ªëng th·ª±c t·∫ø | Thu·∫≠t to√°n khuy√™n d√πng |
|-----------|---------------------|--------------------------|
| **CSDL (Database)** | S·∫Øp x·∫øp b·∫£n ghi theo nhi·ªÅu ti√™u ch√≠ (VD: t√™n, ng√†y sinh) | Merge Sort (·ªïn ƒë·ªãnh, d·ªÖ song song h√≥a) |
| **Game / Realtime Stats** | D·ªØ li·ªáu nh·ªè, thay ƒë·ªïi li√™n t·ª•c | Insertion Sort (nhanh khi g·∫ßn s·∫Øp) |
| **X·ª≠ l√Ω log / file c·ª±c l·ªõn** | D·ªØ li·ªáu kh√¥ng th·ªÉ load h·∫øt v√†o RAM | Merge Sort (External Sort) |
| **Machine Learning / AI** | Chu·∫©n h√≥a, s·∫Øp ƒë·∫∑c tr∆∞ng ƒë·∫ßu v√†o | Quick Sort (in-place, t·ªëc ƒë·ªô cao) |
| **Ph·∫ßn m·ªÅm nh√∫ng / gi·ªõi h·∫°n b·ªô nh·ªõ** | S·∫Øp th·ª© t·ª± sensor, t√≠n hi·ªáu | Heap Sort (√≠t RAM, ·ªïn ƒë·ªãnh) |
| **X·ª≠ l√Ω ·∫£nh / pixel** | S·∫Øp gi√° tr·ªã ƒëi·ªÉm ·∫£nh | Counting Sort, Radix Sort |
| **·ª®ng d·ª•ng t√†i ch√≠nh** | D·ªØ li·ªáu l·ªõn, c·∫ßn ·ªïn ƒë·ªãnh th·ª© t·ª± | Merge Sort, Radix Sort |

### K·∫øt lu·∫≠n

- Kh√¥ng c√≥ **thu·∫≠t to√°n s·∫Øp x·∫øp ‚Äút·ªët nh·∫•t tuy·ªát ƒë·ªëi‚Äù**, m√† l√† **ph√π h·ª£p nh·∫•t v·ªõi t·ª´ng t√¨nh hu·ªëng**.
- G·ª£i √Ω ch·ªçn nhanh:
    - **D·ªØ li·ªáu nh·ªè ho·∫∑c g·∫ßn s·∫Øp x·∫øp:** `Insertion` / `Shell Sort`
    - **D·ªØ li·ªáu l·ªõn, c·∫ßn ·ªïn ƒë·ªãnh:** `Merge Sort`
    - **D·ªØ li·ªáu l·ªõn, c·∫ßn t·ªëc ƒë·ªô cao, √≠t RAM:** `Quick Sort` ho·∫∑c `Heap Sort`
    - **D·ªØ li·ªáu s·ªë nguy√™n / ph·∫°m vi h·∫πp:** `Counting`, `Radix`
    - **D·ªØ li·ªáu ph√¢n b·ªë ƒë·ªÅu:** `Bucket Sort`
